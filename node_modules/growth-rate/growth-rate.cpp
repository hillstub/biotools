#include <node.h>
#include <algorithm>
#include <iostream>
#include <numeric>
#include <vector>
#include <cmath>

using namespace v8;

double slope(const std::vector<double>& x, const std::vector<double>& y, const int start, const int end) {
    const auto n    = 1+end - start;
    const auto s_x  = std::accumulate(x.begin()+start, x.begin()+end+1, 0.0);  
    const auto s_y  = std::accumulate(y.begin()+start, y.begin()+end+1, 0.0);
    const auto s_xx = std::inner_product(x.begin()+start, x.begin()+end+1, x.begin()+start, 0.0);
    const auto s_xy = std::inner_product(x.begin()+start, x.begin()+end+1, y.begin()+start, 0.0);
    const auto a    = (n * s_xy - s_x * s_y) / (n * s_xx - s_x * s_x);
    return a;
}

double intercept(const std::vector<double>& x, const std::vector<double>& y, const int start, const int end) {
    const auto n    = 1+end - start;
    const auto s_x  = std::accumulate(x.begin()+start, x.begin()+end+1, 0.0);  
    const auto s_y  = std::accumulate(y.begin()+start, y.begin()+end+1, 0.0);
    const auto s_xx = std::inner_product(x.begin()+start, x.begin()+end+1, x.begin()+start, 0.0);
    const auto s_xy = std::inner_product(x.begin()+start, x.begin()+end+1, y.begin()+start, 0.0);
    const auto slope    = (n * s_xy - s_x * s_y) / (n * s_xx - s_x * s_x);
    const auto a    = ((s_y / n) - slope * (s_x / n));
    return a;
}

void convert_ln(std::vector<double>& v){
    std::for_each( v.begin(), v.end(), [](double & x)
    {           
     x = log(x); 
 });
}



class timePoint {
public:
    timePoint(double slope,double x1,double x2): _slope(slope), _x1(x1), _x2(x2) {}
    double getSlope() const { return _slope; }
    double getX1() const { return _x1; }
    double getX2() const { return _x2; }
    void setSlope(double slope) { _slope = slope; }
    void setX(double x1) { _x1 = x1; }
    void setY(double x2) { _x2 = x2; }
private:
    double _slope;
    double _x1;
    double _x2;
};

bool myfn(const timePoint& i, const timePoint& j) { return i.getSlope()<j.getSlope(); }

std::vector<timePoint>::const_iterator getMaxMaxTimepoint(std::vector<timePoint>& tp, double max_slope){
    double longest_interval = 0;
    std::vector<timePoint>::const_iterator max_timepoint;
    for(std::vector<timePoint>::const_iterator it = tp.begin(); it != tp.end(); ++it) {
        if((*it).getSlope() >= max_slope*.95 && ((*it).getX2()-(*it).getX1()) > longest_interval){
            max_timepoint = it;
            longest_interval = (*it).getX2()-(*it).getX1();
        }
    }
    return max_timepoint;
}

// Returns the Nth number in the fibonacci sequence where N is the first
// argument passed.
Handle<Value> getRate(const Arguments& args) {
    HandleScope scope;

    // Check that there are enough arguments. If we access an index that doesn't
    // exist, it'll be Undefined().
    if (args.Length() < 1) {
        // No argument was passed. Throw an exception to alert the user to
        // incorrect usage. Alternatively, we could just use 0.
        return ThrowException(
            Exception::TypeError(String::New("First argument must be a number"))
            );
    }

    //convert the 2nd argument into a V8 Local<value> type
    Local<Value> x_js = args[0];
    Local<Value> y_js = args[1]; 
    //make sure args is an array
    if(x_js->IsArray() && y_js->IsArray()){
        Local<Array> arr = Local<Array>::Cast(x_js);
        int length = 0;
        length = arr->Get(String::New("length"))->ToObject()->Uint32Value();
        std::vector<double> xvals(length);
        for(int i=0; i<length; i++)
        {
            if(arr->Get(Number::New(i))->IsNumber()){
                xvals[i] = arr->Get(Number::New(i))->NumberValue();
            }
            else{
                ThrowException(Exception::TypeError(String::New("Invalid values in array.")));
                return scope.Close(Undefined());
            }
        }
       // return scope.Close(Integer::New(xvals.size()));      

        arr = Local<Array>::Cast(y_js);
        length = 0;
        length = arr->Get(String::New("length"))->ToObject()->Uint32Value();
        std::vector<double> yvals(length);
        for(int i=0; i<length; i++)
        {
            if(arr->Get(Number::New(i))->IsNumber()){
                yvals[i] = arr->Get(Number::New(i))->NumberValue();
            }
            else{
                ThrowException(Exception::TypeError(String::New("Invalid values in array.")));
                return scope.Close(Undefined());
            }
        }
       // return scope.Close(Integer::New(yvals.size()));      

        convert_ln(yvals);
        std::vector<timePoint> timepoints;
        int a = 0;
        double slp;
        for(std::vector<double>::const_iterator it = xvals.begin(); it != xvals.end()-5; ++it, a++) {
            int b = a+5;
            for(std::vector<double>::const_iterator nit = xvals.begin()+b; nit != xvals.end(); ++nit, b++) {
                slp = slope(xvals, yvals, a, b);
                timePoint newpoint(slp,a,b);
                timepoints.push_back(newpoint);
            }

        } 

        std::vector<timePoint>::iterator max_timepoint =  std::max_element(timepoints.begin(),timepoints.end(),myfn);
        std::vector<timePoint>::const_iterator maxmax_timepoint = getMaxMaxTimepoint(timepoints,(*max_timepoint).getSlope());
        std::cout << '[' << (*maxmax_timepoint).getX1() << '-' << (*maxmax_timepoint).getX2() << ']' << (*maxmax_timepoint).getSlope();   
        Local<Object> obj = Object::New();
        auto x1 = (*maxmax_timepoint).getX1();
        auto x2 = (*maxmax_timepoint).getX2();
        obj->Set(String::NewSymbol("slope"), Number::New((*maxmax_timepoint).getSlope()));
        obj->Set(String::NewSymbol("x1"), Number::New(x1));
        obj->Set(String::NewSymbol("x2"), Number::New(x2));
        obj->Set(String::NewSymbol("intercept"), Number::New(intercept(xvals, yvals, x1, x2)));
        return scope.Close(obj);      
    }
 /*   // Cast a value to a specific type. See
    // http://izs.me/v8-docs/classv8_1_1Value.html for available To*() functions
    // and type checking functions. When converting to integer, make sure the
    // POD type you use is big enough!
    Local<Integer> integer = args[0]->ToInteger();
    int32_t seq = integer->Value();

    // Also possible in one call. (Don't forget HandleScope, otherwise the
    // intermediate Local handle won't be cleaned up!)
    // int32_t seq = args[0]->ToInteger()->Value();

    // Check for invalid parameter.
    if (seq < 0) {
        return ThrowException(Exception::TypeError(String::New(
            "Fibonacci sequence number must be positive")));
    }

    // The actual algorithm.
    int32_t current = 1;
    for (int32_t previous = -1, next = 0, i = 0; i <= seq; i++) {
        next = previous + current;
        previous = current;
        current = next;
    }*/


    }

    void RegisterModule(Handle<Object> target) {
        target->Set(String::NewSymbol("get_rate"),
            FunctionTemplate::New(getRate)->GetFunction());
    }

    NODE_MODULE(growth_rate, RegisterModule);
